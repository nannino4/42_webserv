#include "server.hpp"

// default constructor
Server::Server(int const &kqueue_epoll_fd) : kqueue_epoll_fd(kqueue_epoll_fd), client_body_size(0), default_location()
{
	default_location.setRoot(DEFAULT_ROOT);
	default_location.addAllowedMethod("GET");
}

// copy constructor
Server::Server(Server const &other) : kqueue_epoll_fd(other.getKqueueEpollFd()) { *this = other; }

// assign operator overload
Server &Server::operator=(Server const &other)
{
	names = other.names;
	error_pages = other.error_pages;
	client_body_size = other.client_body_size;
	locations = other.locations;
	return *this;
}

// destructor
Server::~Server() {}

// getters
int const								&Server::getKqueueEpollFd() const { return kqueue_epoll_fd; }
std::vector<std::string> const			&Server::getNames() const { return names; }
std::map<int,std::string> const			&Server::getErrorPages() const { return error_pages; }
size_t const							&Server::getClientBodySize() const { return client_body_size; }
std::map<std::string,Location> const	&Server::getLocations() const { return locations; }

// utility
bool	Server::isName(std::string const &name_to_match) const
{
	for (std::vector<std::string>::const_iterator i = names.begin(); i != names.end(); ++i)
	{
		if (!i->compare(name_to_match))
			return true;
	}
	return false;
}

// operator overload
std::ostream &operator<<(std::ostream &os, Server const &server)
{
	os << "\nServer introducing itself:\n";
	os << "kqueue_epoll_fd:\n" << server.kqueue_epoll_fd << std::endl;
	os << "names:\n";
	for (std::vector<std::string>::const_iterator it = server.names.begin(); it != server.names.end(); ++it)
	{
		os << *it << std::endl;
	}
	os << "error_pages:\n";
	for (std::map<int, std::string>::const_iterator it = server.error_pages.begin(); it != server.error_pages.end(); ++it)
	{
		os << "code:" << it->first << "\tpath:" << it->second << std::endl;
	}
	os << "client_body_size:\n" << server.client_body_size << std::endl;
	os << "locations:\n";
	for (std::map<std::string,Location>::const_iterator it = server.locations.begin(); it != server.locations.end(); ++it)
	{
		os << it->second << std::endl;
	}
	os << "\nServer introduction is over" << std::endl;
	return os;
}

// error page to body
void Server::errorPageToBody(Response &response)
{
	std::map<int,std::string>::const_iterator	it;

	if ((it = error_pages.find(std::atoi(response.getStatusCode().c_str()))) != error_pages.end())
	{
		std::ifstream	error_page_file(it->second);
		std::string		line;

		while (error_page_file.good())
		{
			getline(error_page_file, line);
			response.setBody(response.getBody() + line + "\n");
		}
		response.addNewHeader(std::pair<std::string,std::string>("last-modified", last_modified(it->second)));
	}
	else
	{
		std::string string;

		string = "<html><head><title>Error " + response.getStatusCode() + " - " + response.getReasonPhrase() + "</title>\n" \
				+ "<link rel=\"stylesheet\" href=\"/pages/base.css\"\n" \
				+ "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n" \
				+ "</head><body><main><center><br /><br /><br /><br /><br /><br/>\n" \
				+ "<h1>Autogenerated Error Page</h1>\n" \
				+ "<h2>Error: " + response.getStatusCode() + "</h1>\n" \
				+ "<h2>" + response.getReasonPhrase() + "</h3\n" \
				+ "<br /><br /><br /><br /></center></main></body></html>\n" \
				+ "\r\n\r\n";
		response.setBody(string);
	}
}

// TODO
// header content-type
// header content-lenght
// conditional operations (if-modified, etc...)
// prepareResponse
void Server::prepareResponse(ConnectedClient *client)
{
	Request										&request = client->request;
	Response									&response = client->response;

	//debug
	std::cout << "---------------------------------------" << std::endl;
	std::cout << "Server::prepareResponse()" << std::endl;
	std::cout << "printing the request..." << std::endl;
	std::cout << client->request << std::endl;
	std::cout << "printing the request location..." << std::endl;
	std::cout << *client->request.getLocation() << std::endl;
	std::cout << "---------------------------------------" << std::endl;

	// add "Date" header
	response.addNewHeader(std::pair<std::string,std::string>("Date", date()));
	// add "Connection" header
	response.addNewHeader(std::pair<std::string,std::string>("Connection", "Close"));

	if (!request.isValid())
	{
		//TODO the code and response phrase will be set in the default_server
		errorPageToBody(response);
	}
	else
	{
		// the request is valid

		// add the location root path to the request path
		request.setPath(request.getLocation()->getRoot() + request.getPath());

		// check if the method is allowd
		if (!request.getLocation()->isMethodAllowed(request.getMethod()))
		{
			// the method requested is not allowed
			response.setStatusCode("405");
			response.setReasonPhrase("Method Not Allowed");

			// add "Allow" header
			std::string allow = "";
			for (std::vector<std::string>::const_iterator it = request.getLocation()->getAllowedMethods().begin(); it != request.getLocation()->getAllowedMethods().end(); ++it)
			{
				if (it != request.getLocation()->getAllowedMethods().begin())
				{
					allow += ", ";
				}
				allow += *it;
			}
			response.addNewHeader(std::pair<std::string,std::string>("Allow", allow));
			errorPageToBody(response);
		}
		else if (request.getLocation()->isRedirection())
		{
			// there is a redirection
			response.setStatusCode(std::to_string(request.getLocation()->getRedirection().second));
			response.setReasonPhrase("Moved Permanently");
			response.addNewHeader(std::pair<std::string,std::string>("Location", request.getLocation()->getRedirection().first));
			// generateAutoIndex();	// TODO why?
		}
		else
		{
			// the method requested is allowed
			if (!request.getMethod().compare("GET"))
			{
				methodGet(request, response);
			}
			else if (!request.getMethod().compare("POST"))
			{
				methodPost(request, response);
			}
			else if (!request.getMethod().compare("DELETE"))
			{
				methodDelete(request, response);
			}
		}
	}
	response.createResponse();
}

// GET method
void Server::methodGet(Request &request, Response &response)
{
	std::ifstream		file;
	struct stat			file_stat;
	std::stringstream	line;

	// get information about the file identified by path
	if (stat((request.getPath()).c_str(), &file_stat) == 0)
	{
		// check whether path identifies a regular file, or a directory
	    if (S_ISDIR(file_stat.st_mode))			// path identifies a directory
		{
	        manageDir(request, response);
		}
	    else if (S_ISREG(file_stat.st_mode))	// path identifies a regular file
		{
	        fileToBody(request, response);
		}
		else									// path identifies no directory nor file
		{
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
	}
	else	// path is invalid
		{
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
}

// POST method
void Server::methodPost(Request &request, Response &response)
{
	std::cout << request << response;
}

// PUT method
/* void Server::methodPost(Request &request, Response &response)
{
	struct stat file_stat;
    stat((request.getPath()).c_str(), &file_stat);

	if (S_ISDIR(file_stat.st_mode))
	{
		response.setStatusCode("500");
		response.setReasonPhrase("Internal Server Error");
		return ;
	}
	else if (S_ISREG(file_stat.st_mode))
	{
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else
	{
		response.setStatusCode("201");
		response.setReasonPhrase("Created");
	}
	std::fstream file((request.getPath()).c_str(), std::fstream::in | std::fstream::out | std::fstream::trunc);
	file << request.getBody();
	file.close();
	//TODO review
}*/

// DELETE method
void Server::methodDelete(Request &request, Response &response)
{
	std::ifstream	file;
	struct stat		file_stat;

    if (stat((request.getPath()).c_str(), &file_stat) == 0)
	{
		// the path is valid
		if (S_ISREG(file_stat.st_mode))
		{
			// the path identifies a regular file
			unlink((request.getPath()).c_str());
			response.setStatusCode("200");
			response.setReasonPhrase("OK");
		}
		else
		{
			// the path does not identify a regular file
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
	}
	else
	{
		// the path is invalid
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
	}
}

// get file to body
void Server::fileToBody(Request &request, Response &response) 
{
	std::ifstream		file;
	std::stringstream	line;
	std::string			cgi_script;
	std::string			file_extension;
	size_t				pos;

	file.open(request.getPath());
	if (file.is_open())
	{
		// check for extension
		pos = request.getPath().find_last_of('.');
		if (pos != std::string::npos)
		{
			file_extension = request.getPath().substr(pos);
			if (request.getLocation()->getCgi().find(file_extension) != request.getLocation()->getCgi().end())
				cgi_script = request.getLocation()->getCgi().find(file_extension)->second;
		}
		// check for cgi
		if (!cgi_script.empty())
		{
			// file extension matches cgi
			convertCGI(request, response);
			response.addNewHeader(std::pair<std::string,std::string>("Content-Lenght", std::to_string(response.getBody().size())));
		}
		else
		{
			// no cgi match
			line << file.rdbuf();
			response.setBody(line.str());
			response.addNewHeader(std::pair<std::string,std::string>("last-modified", last_modified(request.getPath())));
		}
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else if (file.fail())
	{
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
	}
}

// cgi
void Server::convertCGI(Request &request, Response &response)
{
    std::string tmp;
    std::string body;
	size_t		pos;
	Cgi			cgi(request);

	body = cgi.run_cgi("/usr/local/bin/php-cgi");
	pos = body.find("\r\n\r\n");
	if (pos != std::string::npos)
	{
		pos += 4;
		tmp = body.substr(0, pos);
		body.erase(0, pos);		
		takeHeaders(tmp, response);
	}
	response.setBody(body);
}

// take headers from CGI return
void Server::takeHeaders(std::string tmp, Response &response)
{
	std::stringstream file(tmp);
	std::string line;

	while (getline(file, line))
	{
		std::stringstream	sline(line);
		std::string			key;

		while (getline(sline, key, ':'))
		{
			std::string value;
			sline >> std::ws;
			if (getline(sline, value, '\r'))
				response.addNewHeader(std::pair<std::string, std::string>(key, value));
		}
	}
}

// manage case in which path identifies a directory
void Server::manageDir(Request &request, Response &response)
{
	struct stat	file_stat;

	if (!request.getLocation()->getIndex().empty() && \
			stat(std::string(request.getPath() + request.getLocation()->getIndex()).c_str(), &file_stat) == 0 && \
			S_ISREG(file_stat.st_mode))
	{
		// an index exists and it is a file
		request.setPath(request.getPath() + request.getLocation()->getIndex());
		fileToBody(request, response);
	}
	else if (request.getLocation()->isAutoindex())
	{
		// no indexes, but autoindex is on
		generateAutoIndex(request, response);
	}
	else
	{
		// no indexes, no autoindex
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
	}
}

// generate autoindex
void Server::generateAutoIndex(Request &request, Response &response)
{
	DIR 				*dir;
	struct dirent		*ent;
	std::stringstream	line;

	if ((dir = opendir(("./" + request.getPath()).c_str())) != nullptr)
	{
		response.setStatusCode("200");
		response.setReasonPhrase("OK");

		line << "<html><head><title>Index of " << request.getPath() << response.getReasonPhrase() << "</title>";
		line << "<link rel=\"stylesheet\" href=\"/pages/base.css\"";
		line << "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">";
		line << "</head><body><main>";
		
		line << "<h1>Index of " << request.getPath() << "</h1>\n";
		line << "<table>";
		/* print all the files and directories within directory */
		while ((ent = readdir(dir)) != nullptr)
		{
			if (std::string(ent->d_name) != ".")
			{
				line << "<tr><td><a href=\"" << ent->d_name << "\">";
				line << ent->d_name << "</a></td></tr>";
			}
		}
		line << "</table></main></body></html>";
		response.setBody(line.str());
		closedir(dir);
	}
	else
	{
		// could not open directory
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
	}
}
