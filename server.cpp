#include "server.hpp"

// default constructor
Server::Server(int const &kqueue_epoll_fd) : kqueue_epoll_fd(kqueue_epoll_fd), client_body_size(0), default_location()
{
	default_location.setRoot(my_getcwd() + DEFAULT_ROOT);
	default_location.addAllowedMethod("GET");
}

// copy constructor
Server::Server(Server const &other) : kqueue_epoll_fd(other.getKqueueEpollFd()) { *this = other; }

// assign operator overload
Server &Server::operator=(Server const &other)
{
	names = other.names;
	error_pages = other.error_pages;
	client_body_size = other.client_body_size;
	locations = other.locations;
	return *this;
}

// destructor
Server::~Server() {}

// getters
int const								&Server::getKqueueEpollFd() const { return kqueue_epoll_fd; }
std::vector<std::string> const			&Server::getNames() const { return names; }
std::map<int,std::string> const			&Server::getErrorPages() const { return error_pages; }
size_t const							&Server::getClientBodySize() const { return client_body_size; }
std::map<std::string,Location> const	&Server::getLocations() const { return locations; }

// utility
bool	Server::isName(std::string const &name_to_match) const
{
	for (std::vector<std::string>::const_iterator i = names.begin(); i != names.end(); ++i)
	{
		if (!i->compare(name_to_match))
			return true;
	}
	return false;
}

// operator overload
std::ostream &operator<<(std::ostream &os, Server const &server)
{
	os << "\nServer introducing itself:\n";
	os << "kqueue_epoll_fd:\n" << server.kqueue_epoll_fd << std::endl;
	os << "names:\n";
	for (std::vector<std::string>::const_iterator it = server.names.begin(); it != server.names.end(); ++it)
	{
		os << *it << std::endl;
	}
	os << "error_pages:\n";
	for (std::map<int, std::string>::const_iterator it = server.error_pages.begin(); it != server.error_pages.end(); ++it)
	{
		os << "code:" << it->first << "\tpath:" << it->second << std::endl;
	}
	os << "client_body_size:\n" << server.client_body_size << std::endl;
	os << "locations:\n";
	for (std::map<std::string,Location>::const_iterator it = server.locations.begin(); it != server.locations.end(); ++it)
	{
		os << it->second << std::endl;
	}
	os << "\nServer introduction is over" << std::endl;
	return os;
}

// error page to body
void Server::errorPageToBody(Response &response)
{
	std::map<int,std::string>::const_iterator	it;

	if ((it = error_pages.find(std::atoi(response.getStatusCode().c_str()))) != error_pages.end())
	{
		std::ifstream	error_page_file(it->second);
		std::string		line;

		while (error_page_file.good())
		{
			getline(error_page_file, line);
			response.setBody(response.getBody() + line + "\n");
		}
	}
	else
	{
		std::string string;

		string = "<html><head><title>Error " + response.getStatusCode() + " - " + response.getReasonPhrase() + "</title>\n" \
				+ "<link rel=\"stylesheet\" href=\"/pages/base.css\"\n" \
				+ "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n" \
				+ "</head><body><main><center><br /><br /><br /><br /><br /><br/>\n" \
				+ "<h1>Autogenerated Error Page</h1>\n" \
				+ "<h2>Error: " + response.getStatusCode() + "</h1>\n" \
				+ "<h2>" + response.getReasonPhrase() + "</h3\n" \
				+ "<br /><br /><br /><br /></center></main></body></html>\n" \
				+ "\r\n\r\n";
		response.setBody(string);
	}
}

// TODO
// header content-type
// header content-lenght
// conditional operations (if-modified, etc...)
// prepareResponse
void Server::prepareResponse(ConnectedClient *client)
{
	Request										&request = client->request;
	Response									&response = client->response;

	// add "Date" header
	//TODO

	// add "Connection" header
	response.addNewHeader(std::pair<std::string,std::string>("Connection", "Close"));

	if (!request.isValid())
	{
		//TODO the code and response phrase will be set in the default_server
		errorPageToBody(response);
	}
	else
	{
		// the request is valid

		// add the location root path to the request path
		request.setPath(request.getLocation()->getRoot() + request.getPath());

		// check if the method is allowd
		if (!request.getLocation()->isMethodAllowed(request.getMethod()))
		{
			// the method requested is not allowed
			response.setStatusCode("405");
			response.setReasonPhrase("Method Not Allowed");

			// add "Allow" header
			std::string allow = "";
			for (std::vector<std::string>::const_iterator it = request.getLocation()->getAllowedMethods().begin(); it != request.getLocation()->getAllowedMethods().end(); ++it)
			{
				if (it != request.getLocation()->getAllowedMethods().begin())
				{
					allow += ", ";
				}
				allow += *it;
			}
			response.addNewHeader(std::pair<std::string,std::string>("Allow", allow));
			errorPageToBody(response);
		}
		else if (request.getLocation()->isRedirection())
		{
			// there is a redirection
			response.setStatusCode(std::to_string(request.getLocation()->getRedirection().second));
			response.setReasonPhrase("Moved Permanently");
			response.addNewHeader(std::pair<std::string,std::string>("Location", request.getLocation()->getRedirection().first));
			// generateAutoIndex();	// TODO why?
		}
		else
		{
			// the method requested is allowed
			if (!request.getMethod().compare("GET"))
			{
				methodGet(request, response);
			}
			else if (!request.getMethod().compare("POST"))
			{
				methodPost(request, response);
			}
			else if (!request.getMethod().compare("DELETE"))
			{
				methodDelete(request, response);
			}
		}
	}
	response.createResponse();
}

// GET method
void Server::methodGet(Request const &request, Response &response)
{
	std::ifstream		file;
	struct stat			file_stat;
	std::stringstream	line;

	// get information about the file identified by path
	if (stat((request.getPath()).c_str(), &file_stat) == 0)
	{
		// check whether path identifies a regular file, or a directory
	    if (S_ISDIR(file_stat.st_mode))			// path identifies a directory
		{
	        manageDir(request, response);
		}
	    else if (S_ISREG(file_stat.st_mode))	// path identifies a regular file
		{
	        getFile(request.getPath(), response);	//TODO cambia nome in fileToBody
		}
		else									// path identifies no directory nor file
		{
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
	}
	else	// path is invalid
		{
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
}

// POST method
void Server::methodPost(Request const &request, Response &response)
{
	struct stat file_stat;
    stat((request.getPath()).c_str(), &file_stat);

	if (S_ISDIR(file_stat.st_mode))
	{
		response.setStatusCode("500");
		response.setReasonPhrase("Internal Server Error");
		return ;
	}
	else if (S_ISREG(file_stat.st_mode))
	{
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else
	{
		response.setStatusCode("201");
		response.setReasonPhrase("Created");
	}
	std::fstream file((request.getPath()).c_str(), std::fstream::in | std::fstream::out | std::fstream::trunc);
	file << request.getBody();
	file.close();
	//TODO review
}

// DELETE method
void Server::methodDelete(Request const &request, Response &response)
{
	std::ifstream	file;
	struct stat		file_stat;

    if (stat((request.getPath()).c_str(), &file_stat) == 0)
	{
		// the path is valid
		if (S_ISREG(file_stat.st_mode))
		{
			// the path identifies a regular file
			unlink((request.getPath()).c_str());
			response.setStatusCode("200");
			response.setReasonPhrase("OK");
		}
		else
		{
			// the path does not identify a regular file
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
		}
	}
	else
	{
		// the path is invalid
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
	}
}

// get file to body
void Server::getFile(std::string const path, Response &response) 
{
	std::ifstream		file;
	std::stringstream	line;

	file.open(path);
	if (file.is_open())
	{
		line << file.rdbuf();
		response.setBody(line.str());
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else if (file.fail())
	{
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
	}
}

// manage case in which path identifies a directory
void Server::manageDir(Request const &request, Response &response)
{
	struct stat	file_stat;

	if (!request.getLocation()->getIndex().empty() && \
			stat(std::string(request.getPath() + request.getLocation()->getIndex()).c_str(), &file_stat) == 0 && \
			S_ISREG(file_stat.st_mode))
	{
		// an index exists and it is a file
		if (request.getPath().at(request.getPath().size() - 1) != '/')
			getFile(request.getPath() + "/" + request.getLocation()->getIndex(), response);
		else
			getFile(request.getPath() + request.getLocation()->getIndex(), response);
	}
	else if (request.getLocation()->isAutoindex())
	{
		// no indexes, but autoindex is on
		//TODO add code and reason phrase (?)
		generateAutoIndex();
	}
	else
	{
		// no indexes, no autoindex
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
	}
}

// generate autoindex
void Server::generateAutoIndex()
{
// 	DIR *dir;
// 	struct dirent *ent;
// 	std::stringstream line;

// 	if ((dir = opendir(("./" + request.getPath()).c_str())) != NULL)
// 	{
// 		line << "<html><head><title>Index of " << request.getPath() << response.getReasonPhrase() << "</title>";
// 		line << "<link rel=\"stylesheet\" href=\"/pages/base.css\"";
// 		line << "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">";
// 		line << "</head><body><main>";
		
// 		line << "<h1>Index of " << request.getPath() << "</h1>\n";
// 		line << "<table>";
// 		/* print all the files and directories within directory */
// 		while ((ent = readdir(dir)) != NULL)
// 		{
// 			if (std::string(ent->d_name) != ".")
// 			{
// 				line << "<tr><td><a href=\"" << ent->d_name << "\">";
// 				line << ent->d_name << "</a></td></tr>";
// 			}
// 		}
// 		line << "</table></main></body></html>";
// 		body = line.str();
// 		closedir (dir);
// 	}
// 	else
// 	{
// 		/* could not open directory */
// 		perror ("could not open directory");
// 		response_status_code = "404";
// 		response.getReasonPhrase() = "File Not Found";
// 		errorPageToBody(response);
// 	}
// 	//TODO review
}
