#include "server.hpp"

// default constructor
Server::Server(int const &kqueue_epoll_fd) : kqueue_epoll_fd(kqueue_epoll_fd), client_body_size(0), default_location() {}

// copy constructor
Server::Server(Server const &other) : kqueue_epoll_fd(other.getKqueueEpollFd()) { *this = other; }

// assign operator overload
Server &Server::operator=(Server const &other)
{
	names = other.names;
	error_pages = other.error_pages;
	client_body_size = other.client_body_size;
	locations = other.locations;
	return *this;
}

// destructor
Server::~Server() {}

// getters
int const								&Server::getKqueueEpollFd() const { return kqueue_epoll_fd; }
std::vector<std::string> const			&Server::getNames() const { return names; }
std::map<int,std::string> const			&Server::getErrorPages() const { return error_pages; }
size_t const							&Server::getClientBodySize() const { return client_body_size; }
std::map<std::string,Location> const	&Server::getLocations() const { return locations; }

// utility
bool	Server::isName(std::string const &name_to_match) const
{
	for (std::vector<std::string>::const_iterator i = names.begin(); i != names.end(); ++i)
	{
		if (!i->compare(name_to_match))
			return true;
	}
	return false;
}

// operator overload
std::ostream &operator<<(std::ostream &os, Server const &server)
{
	os << "\nServer introducing itself:\n";
	os << "kqueue_epoll_fd:\n" << server.kqueue_epoll_fd << std::endl;
	os << "names:\n";
	for (std::vector<std::string>::const_iterator it = server.names.begin(); it != server.names.end(); ++it)
	{
		os << *it << std::endl;
	}
	os << "error_pages:\n";
	for (std::map<int, std::string>::const_iterator it = server.error_pages.begin(); it != server.error_pages.end(); ++it)
	{
		os << "code:" << it->first << "\tpath:" << it->second << std::endl;
	}
	os << "client_body_size:\n" << server.client_body_size << std::endl;
	os << "locations:\n";
	for (std::map<std::string,Location>::const_iterator it = server.locations.begin(); it != server.locations.end(); ++it)
	{
		os << it->second << std::endl;
	}
	os << "\nServer introduction is over" << std::endl;
	return os;
}

// error page to body
void Server::errorPageToBody(Response &response)
{
	std::map<int,std::string>::const_iterator	it;

	if ((it = error_pages.find(std::atoi(response.getStatusCode().c_str()))) != error_pages.end())
	{
		std::ifstream	error_page_file(it->second);
		std::string		line;

		while (error_page_file.good())
		{
			getline(error_page_file, line);
			response.setBody(response.getBody() + line + "\n");
		}
		response.addNewHeader(std::pair<std::string,std::string>("Last-Modified", last_modified(it->second)));
		response.addNewHeader(std::pair<std::string,std::string>("Content-Type", content_type(it->second)));
	}
	else
	{
		std::string string;

		string = "<html><head><title>Error " + response.getStatusCode() + " - " + response.getReasonPhrase() + "</title>\n" \
				+ "<link rel=\"stylesheet\" href=\"/get/base.css\"\n" \
				+ "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n" \
				+ "</head><body><main><center><br /><br /><br /><br /><br /><br/>\n" \
				+ "<h1>Autogenerated Error Page</h1>\n" \
				+ "<h2>Error: " + response.getStatusCode() + "</h1>\n" \
				+ "<h2>" + response.getReasonPhrase() + "</h3\n" \
				+ "<br /><br /><br /><br /></center></main></body></html>\n" \
				+ "\r\n\r\n";
		response.setBody(string);
		response.addNewHeader(std::pair<std::string,std::string>("Content-Type", "text/html"));
	}
}

// prepareResponse
void Server::prepareResponse(ConnectedClient *client)
{
	//debug
	std::cout << "\n-------------------------------" << std::endl;
	std::cout << "Server::prepareResponse()\n\n" << std::endl;

	Request		&request = client->request;
	Response	&response = client->response;

	// add "Date" header
	response.addNewHeader(std::pair<std::string,std::string>("Date", date()));
	// add "Connection" header
	response.addNewHeader(std::pair<std::string,std::string>("Connection", "Close"));
	// set version
	response.setVersion("HTTP/1.1");

	if (!request.isValid())
	{
		errorPageToBody(response);
		response.setIsComplete(true);
	}
	else
	{
		// the request is valid

		// add the location root path to the request path
		request.setPath(request.getLocation()->getRoot() + request.getPath());

		// check if the method is allowd
		if (!request.getLocation()->isMethodAllowed(request.getMethod()))
		{
			// the method requested is not allowed
			response.setStatusCode("405");
			response.setReasonPhrase("Method Not Allowed");

			// add "Allow" header
			std::string allow = "";
			for (std::vector<std::string>::const_iterator it = request.getLocation()->getAllowedMethods().begin(); it != request.getLocation()->getAllowedMethods().end(); ++it)
			{
				if (it != request.getLocation()->getAllowedMethods().begin())
				{
					allow += ", ";
				}
				allow += *it;
			}
			response.addNewHeader(std::pair<std::string,std::string>("Allow", allow));
			errorPageToBody(response);
			response.setIsComplete(true);
		}
		else if (request.getLocation()->isRedirection())
		{
			// there is a redirection
			response.setStatusCode(std::to_string(request.getLocation()->getRedirection().second));
			response.setReasonPhrase("Moved Permanently");
			response.addNewHeader(std::pair<std::string,std::string>("Location", request.getLocation()->getRedirection().first));
			response.setIsComplete(true);
		}
		else
		{
			// the method requested is allowed
			if (!request.getMethod().compare("GET"))
			{
				methodGet(client);
			}
			else if (!request.getMethod().compare("POST"))
			{
				methodPost(client);
			}
			else if (!request.getMethod().compare("DELETE"))
			{
				methodDelete(client);
			}
		}
	}

	if (response.getBody().size() > 0)
	{
		response.addNewHeader(std::pair<std::string,std::string>("Content-Length", std::to_string(response.getBody().size())));
	}
	response.createResponse();

	//debug
	std::cout << "Response:\n" << response.getResponse().substr(0, response.getResponse().find("\r\n\r\n")) << std::endl;
	std::cout << "\nEND of Server::prepareResponse()" << std::endl;
	std::cout << "-------------------------------" << std::endl;
}

// GET method
void Server::methodGet(ConnectedClient *client)
{
	std::ifstream		file;
	struct stat			file_stat;
	std::stringstream	line;
	Request				&request = client->request;
	Response			&response = client->response;

	// get information about the file identified by path
	if (stat((request.getPath()).c_str(), &file_stat) == 0)
	{
		// check whether path identifies a regular file, or a directory
	    if (S_ISDIR(file_stat.st_mode))			// path identifies a directory
		{
	        manageDir(client);
		}
	    else if (S_ISREG(file_stat.st_mode))	// path identifies a regular file
		{
	        fileToBody(client);
		}
		else									// path identifies no directory nor file
		{
			response.setStatusCode("404");
			response.setReasonPhrase("File Not Found");
			errorPageToBody(response);
			response.setIsComplete(true);
		}
	}
	else	// path is invalid
	{
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
		response.setIsComplete(true);
	}
}

// POST method
void Server::methodPost(ConnectedClient *client)
{
	std::ifstream		file;
	std::string			file_extension;
	size_t				pos;
	Request				&request = client->request;
	Response			&response = client->response;

	file.open(request.getPath());
	if (file.is_open())
	{
		// check for extension
		pos = request.getPath().find_last_of('.');
		if (pos != std::string::npos)
		{
			file_extension = request.getPath().substr(pos);
			if (request.getLocation()->getCgi().find(file_extension) != request.getLocation()->getCgi().end())
			{
				request.setCgiPath(request.getLocation()->getCgi().find(file_extension)->second);
			}
		}
		// check for cgi
		if (!request.getCgiPath().empty())
		{
			// file extension matches cgi
			response.initCgi(&client->triggered_event, request);
			if (response.runCgi(request.getCgiPath()))
			{
				response.setStatusCode("500");
				response.setReasonPhrase("Internal Server Error");
				errorPageToBody(response);
			}
			else
			{
				if (response.getCgi().getPostData().size() > 0)
				{
					// add to_cgi[1] to kqueue for WRITE monitoring
					client->triggered_event.events = WRITE;
					client->triggered_event.fd = response.getCgi().getToCgiFd();
					client->triggered_event.is_error = false;
					client->triggered_event.is_hang_up = false;
				#ifdef __MACH__
					struct kevent event;
					bzero(&event, sizeof(event));
					EV_SET(&event, response.getCgi().getToCgiFd(), EVFILT_WRITE, EV_ADD, 0, 0, &client->triggered_event);
					if (kevent(kqueue_epoll_fd, &event, 1, nullptr, 0, nullptr) == -1)
				#elif defined(__linux__)
					struct epoll_event event;
					bzero(&event, sizeof(event));
					event.events = EPOLLIN | EPOLLRDHUP;
					event.data.ptr = &client->triggered_event;
					if (epoll_ctl(kqueue_epoll_fd, EPOLL_CTL_ADD, response.getCgi().getToCgiFd(), &event) == -1)
				#endif
					{
						//error adding fd to epoll/kqueue
						perror("ERROR\nServer.methodPost(): kevent()/epoll_ctl()");
						response.setStatusCode("500");
						response.setReasonPhrase("Internal Server Error");
						errorPageToBody(response);
						response.setIsComplete(true);
				}
				}
				else
				{
					// add from_cgi[0] to kqueue for READ monitoring
					client->triggered_event.events = READ;
					client->triggered_event.fd = response.getCgi().getFromCgiFd();
					client->triggered_event.is_error = false;
					client->triggered_event.is_hang_up = false;
				#ifdef __MACH__
					struct kevent event;
					bzero(&event, sizeof(event));
					EV_SET(&event, response.getCgi().getFromCgiFd(), EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, &client->triggered_event);
					if (kevent(kqueue_epoll_fd, &event, 1, nullptr, 0, nullptr) == -1)
				#elif defined(__linux__)
					struct epoll_event event;
					bzero(&event, sizeof(event));
					event.events = EPOLLIN | EPOLLRDHUP;
					event.data.ptr = &client->triggered_event;
					if (epoll_ctl(kqueue_epoll_fd, EPOLL_CTL_ADD, response.getCgi().getFromCgiFd(), &event) == -1)
				#endif
					{
						//error adding fd to epoll/kqueue
						perror("ERROR\nServer.methodPost(): kevent()/epoll_ctl()");
						response.setStatusCode("500");
						response.setReasonPhrase("Internal Server Error");
						errorPageToBody(response);
						response.setIsComplete(true);
					}
				}
			}
		}
	}
	else if (file.fail())
	{
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
	}
}

// PUT method
/* void Server::methodPost(Request &request, Response &response)
{
	struct stat file_stat;
    stat((request.getPath()).c_str(), &file_stat);

	if (S_ISDIR(file_stat.st_mode))
	{
		response.setStatusCode("500");
		response.setReasonPhrase("Internal Server Error");
		return ;
	}
	else if (S_ISREG(file_stat.st_mode))
	{
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else
	{
		response.setStatusCode("201");
		response.setReasonPhrase("Created");
	}
	std::fstream file((request.getPath()).c_str(), std::fstream::in | std::fstream::out | std::fstream::trunc);
	file << request.getBody();
	file.close();
}*/

void deleteDir(std::string path, Response &response)
{
	DIR 				*dir;
	struct stat			stat_path, stat_entry;
	struct dirent		*ent;

	stat(path.c_str(), &stat_path);
	
	if (S_ISDIR(stat_path.st_mode))
	{
		if ((dir = opendir((path.c_str()))) == NULL)
		{
			response.setStatusCode("403");
			response.setReasonPhrase("Forbidden");
			return;
		}
		while ((ent = readdir(dir)) != NULL)
		{
			if (std::string(ent->d_name) == "." || std::string(ent->d_name) == "..")
				continue ;
			
			stat(std::string(path + "/" + ent->d_name).c_str(), &stat_entry);
			if (S_ISDIR(stat_entry.st_mode))
				deleteDir(std::string(path + "/" + ent->d_name), response);

			if (std::ifstream(std::string(path + "/" + ent->d_name).c_str()).is_open() && unlink(std::string(path + "/" + ent->d_name).c_str()))
			{
				response.setStatusCode("403");
				response.setReasonPhrase("Forbidden");
				return;
			}
		}
		if (rmdir(path.c_str()))
		{
			response.setStatusCode("403");
			response.setReasonPhrase("Forbidden");
			return;
		}
		closedir(dir);
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else if (S_ISREG(stat_path.st_mode))
	{
		if (!std::ifstream(path.c_str()).is_open())
		{
			response.setStatusCode("403");
			response.setReasonPhrase("Forbidden");
			return;
		}
		unlink(path.c_str());
		response.setStatusCode("200");
		response.setReasonPhrase("OK");
	}
	else
	{
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
	}
}


// DELETE method
void Server::methodDelete(ConnectedClient *client)
{
	Request				&request = client->request;
	Response			&response = client->response;

	deleteDir(request.getPath(), response);
	if (response.getStatusCode() != "200")
		errorPageToBody(response);
	response.setIsComplete(true);
}


// get file to body
void Server::fileToBody(ConnectedClient *client)
{
	std::ifstream		file;
	std::stringstream	line;
	std::string			file_extension;
	size_t				pos;
	Request				&request = client->request;
	Response			&response = client->response;

	file.open(request.getPath());
	if (file.is_open())
	{
		// check for extension
		pos = request.getPath().find_last_of('.');
		if (pos != std::string::npos)
		{
			file_extension = request.getPath().substr(pos);
			if (request.getLocation()->getCgi().find(file_extension) != request.getLocation()->getCgi().end())
			{
				request.setCgiPath(request.getLocation()->getCgi().find(file_extension)->second);
			}
		}
		// check for cgi
		if (!request.getCgiPath().empty())
		{
			// file extension matches cgi
			response.initCgi(&client->triggered_event, request);
			if (response.runCgi(request.getCgiPath()))
			{
				// error running cgi
				response.setStatusCode("500");
				response.setReasonPhrase("Internal Server Error");
				errorPageToBody(response);
				response.setIsComplete(true);
			}
			else
			{
				// add from_cgi[0] to kqueue for READ monitoring
				client->triggered_event.events = READ;
				client->triggered_event.fd = response.getCgi().getFromCgiFd();
				client->triggered_event.is_error = false;
				client->triggered_event.is_hang_up = false;
			#ifdef __MACH__
				struct kevent event;
				bzero(&event, sizeof(event));
				EV_SET(&event, response.getCgi().getFromCgiFd(), EVFILT_READ, EV_ADD | EV_CLEAR, 0, 0, &client->triggered_event);
				if (kevent(kqueue_epoll_fd, &event, 1, nullptr, 0, nullptr) == -1)
			#elif defined(__linux__)
				struct epoll_event event;
				bzero(&event, sizeof(event));
				event.events = EPOLLIN | EPOLLRDHUP;
				event.data.ptr = &client->triggered_event;
				if (epoll_ctl(kqueue_epoll_fd, EPOLL_CTL_ADD, response.getCgi().getFromCgiFd(), &event) == -1)
			#endif
				{
					//error adding fd to epoll/kqueue
					perror("ERROR\nServer.fileToBody(): kevent()/epoll_ctl()");
					response.setStatusCode("500");
					response.setReasonPhrase("Internal Server Error");
					errorPageToBody(response);
					response.setIsComplete(true);
				}
			}
		}
		else
		{
			// no cgi match
			line << file.rdbuf();
			response.setBody(line.str());
			response.addNewHeader(std::pair<std::string,std::string>("Last-Modified", last_modified(request.getPath())));
			response.addNewHeader(std::pair<std::string,std::string>("Content-Type", content_type(request.getPath())));
			response.setStatusCode("200");
			response.setReasonPhrase("OK");
			response.setIsComplete(true);
		}
	}
	else if (file.fail())
	{
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
		response.setIsComplete(true);
	}
}

// manage case in which path identifies a directory
void Server::manageDir(ConnectedClient *client)
{
	struct stat			file_stat;
	Request				&request = client->request;
	Response			&response = client->response;

	if (!request.getLocation()->getIndex().empty() && \
			stat(std::string(request.getPath() + request.getLocation()->getIndex()).c_str(), &file_stat) == 0 && \
			S_ISREG(file_stat.st_mode))
	{
		// an index exists and it is a file
		request.setPath(request.getPath() + request.getLocation()->getIndex());
		fileToBody(client);
	}
	else if (request.getLocation()->isAutoindex())
	{
		// no indexes, but autoindex is on
		generateAutoIndex(request, response);
	}
	else
	{
		// no indexes, no autoindex
		response.setStatusCode("404");
		response.setReasonPhrase("File Not Found");
		errorPageToBody(response);
		response.setIsComplete(true);
	}
}

// generate autoindex
void Server::generateAutoIndex(Request &request, Response &response)
{
	DIR 				*dir;
	struct dirent		*ent;
	std::stringstream	line;

	if ((dir = opendir(("./" + request.getPath()).c_str())) != nullptr)
	{
		response.setStatusCode("200");
		response.setReasonPhrase("OK");

		line << "<html><head><title>Index of " << request.getPath() << response.getReasonPhrase() << "</title>";
		line << "<link rel=\"stylesheet\" href=\"/get/base.css\"";
		line << "<meta charset=\"utf-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">";
		line << "</head><body><main>";
		
		line << "<h1>Index of " << request.getPath() << "</h1>\n";
		line << "<table>";
		/* print all the files and directories within directory */
		while ((ent = readdir(dir)) != nullptr)
		{
			if (std::string(ent->d_name) != ".")
			{
				line << "<tr><td><a href=\"" << ent->d_name << "/\">";
				line << ent->d_name << "</a></td></tr>";
			}
		}
		line << "</table></main></body></html>";
		response.setBody(line.str());
		response.addNewHeader(std::pair<std::string,std::string>("Content-Type", "text/html"));
		closedir(dir);
	}
	else
	{
		// could not open directory
		response.setStatusCode("403");
		response.setReasonPhrase("Forbidden");
		errorPageToBody(response);
	}
	response.setIsComplete(true);
}
